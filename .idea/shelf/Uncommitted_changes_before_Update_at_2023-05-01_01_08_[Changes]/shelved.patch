Index: src/main/Playing.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package main;\r\n\r\nimport helpers.FontLoader;\r\nimport helpers.ImageLoader;\r\nimport objects.ObjectManager;\r\n\r\nimport java.awt.*;\r\nimport java.awt.event.KeyEvent;\r\nimport java.awt.event.MouseEvent;\r\nimport java.awt.font.TextLayout;\r\nimport java.awt.geom.AffineTransform;\r\nimport java.awt.image.BufferedImage;\r\nimport java.awt.image.ConvolveOp;\r\nimport java.awt.image.Kernel;\r\n\r\nimport static constants.Direction.*;\r\nimport static constants.GameState.*;\r\nimport static main.Player.PLAYER_HEIGHT;\r\nimport static main.Player.PLAYER_WIDTH;\r\nimport static objects.Coin.coinCount;\r\n\r\n/**\r\n * Playing is where the player plays the game\r\n * The playing state initializes classes for the game, including player, levels and more\r\n * This class also shows overlays for example paused or game over depending on the game state\r\n */\r\npublic class Playing extends GameState {\r\n\r\n    // ====== Variables ======\r\n    private static final float PLAYER_SCALE = 1.33f;\r\n    private final Player player;\r\n    private Point spawnPoint;\r\n    private int levelOffset;\r\n    private int shakeOffset;\r\n    private long lastSec;\r\n    private boolean movingLeft, movingRight;\r\n    private static final int START_T = 300;\r\n    private int t = START_T;\r\n    private static final Font CUSTOM_FONT = FontLoader.loadFont(\"/fonts/inside-out.ttf\");\r\n\r\n    private final EnemyManager enemyManager;\r\n    private final LevelManager levelManager;\r\n    private final ObjectManager objectManager;\r\n\r\n    // Drawing background\r\n    private static final BufferedImage SUN = ImageLoader.loadImage(\"/ui/sun.png\");\r\n    private static final BufferedImage SKY = ImageLoader.loadImage(\"/ui/sky.png\");\r\n    private static final BufferedImage BIG_CLOUDS = ImageLoader.loadImage(\"/ui/big-clouds.png\");\r\n    private static final BufferedImage SMALL_CLOUDS = ImageLoader.loadImage(\"/ui/small-clouds.png\");\r\n    private static final BufferedImage FOREST = ImageLoader.loadImage(\"/ui/forest.png\");\r\n\r\n    // Drawing UI\r\n    private static final BufferedImage MARIO = ImageLoader.loadImage(\"/ui/mario-icon.png\");\r\n    private static final BufferedImage COIN = ImageLoader.loadImage(\"/ui/coin-icon.png\");\r\n    private static final int MARIO_W = (int) (19*Game.SCALE*2);\r\n    private static final int MARIO_H = (int) (19*Game.SCALE*2);\r\n    private static final int MARIO_X = (int) (MARIO_W + 10 * Game.SCALE);\r\n    private static final int MARIO_Y = (int) (MARIO_H / 1.5);\r\n    private static final int COIN_Y = (int) (MARIO_H / 1.5 + MARIO_H + 10 * Game.SCALE);\r\n    private static final int TOP_Y = (int) (MARIO_Y + MARIO_H - 4 * Game.SCALE);\r\n    private static final int X_NEXT_TO_ICON = (int) (MARIO_X + MARIO_W + 4 * Game.SCALE);\r\n    private static final float sizeX = 21 * Game.SCALE;\r\n    private static final float size00 = 35 * Game.SCALE;\r\n\r\n    // ====== Constructor ======\r\n    public Playing(Game game) {\r\n        super(game);\r\n\r\n        // Init classes\r\n        levelManager    = new LevelManager();\r\n        player          = new Player(PLAYER_WIDTH * PLAYER_SCALE * Game.SCALE, PLAYER_HEIGHT * PLAYER_SCALE * Game.SCALE, game);\r\n        enemyManager    = new EnemyManager();\r\n        objectManager   = new ObjectManager();\r\n\r\n        // Set level for player class\r\n        player.setLevel(levelManager.getLevel());\r\n        resetSpawnPoint();\r\n    }\r\n\r\n    // ====== Update methods ======\r\n\r\n    public void update() {\r\n        // Update the player and enemies\r\n        player.update();\r\n        enemyManager.update(levelManager.getLevel(), player);\r\n        objectManager.update(levelManager.getLevel(), player);\r\n\r\n        // Update playing stuff\r\n        updateLevelOffset();\r\n        updatePlayerOutsideLevel();\r\n        updateFinalPointState();\r\n        updateShake();\r\n        updateCountdownTimer();\r\n    }\r\n\r\n    private void updateLevelOffset() {\r\n        // Get player X position\r\n        int playerX = (int) player.hitbox.x;\r\n\r\n        // Update level offset with player and half the game width to center the player\r\n        levelOffset = playerX - Game.GAME_WIDTH / 2;\r\n\r\n        // Reset level offset if at the leftmost of the map\r\n        if (levelOffset < 0)\r\n            levelOffset = 0;\r\n\r\n        // Reset level offset if at the rightmost of the map\r\n        final int maxLevelOffset = levelManager.getLevel().getMaxLevelOffset();\r\n        if (levelOffset > maxLevelOffset)\r\n            levelOffset = maxLevelOffset;\r\n    }\r\n\r\n    private void updatePlayerOutsideLevel() {\r\n        int playerY = (int) player.hitbox.y / Game.TILES_SIZE;\r\n        int bottomY = Game.TILES_IN_HEIGHT;\r\n        boolean isPlayerBelowLevel = playerY >= bottomY + 3;\r\n\r\n        if (isPlayerBelowLevel)\r\n            game.setGameState(GAME_OVER);\r\n    }\r\n\r\n    private void updateShake() {\r\n        shakeOffset = 0;\r\n\r\n        if (player.isHit()) {\r\n            // The maximum amount of pixels to shake the screen\r\n            final int shakeAmount = 10;\r\n            shakeOffset = (int) (Math.random() * shakeAmount * 2) - shakeAmount;\r\n        }\r\n    }\r\n\r\n    private void updateFinalPointState() {\r\n        // Get the X and Y position for the player and \"final point\"\r\n        int finalX = levelManager.getLevel().getFinalPoint().x / Game.TILES_SIZE;\r\n        int finalY = levelManager.getLevel().getFinalPoint().y / Game.TILES_SIZE;\r\n        int playerX = (int) player.getHitbox().x / Game.TILES_SIZE;\r\n        int playerY = (int) player.getHitbox().y / Game.TILES_SIZE;\r\n\r\n//        System.out.println(\"X: \" + playerX + \" | Y: \" + playerY);\r\n//        System.out.println(\"X: \" + finalX + \" | Y: \" + finalY);\r\n\r\n        // Player is inside the final position\r\n        // Exact X position\r\n        // At the exact Y position on the bottom or up to 3 tiles above it.\r\n        if (playerX == finalX) {\r\n            if (playerY >= finalY - 3 && playerY <= finalY) {\r\n                setLevelCompleted();\r\n            }\r\n        }\r\n    }\r\n\r\n    private void updateCountdownTimer() {\r\n        long sec = System.currentTimeMillis() / 1000;\r\n        if (sec != lastSec) {\r\n            t--;\r\n            lastSec = sec;\r\n        }\r\n    }\r\n\r\n    // ====== Draw ======\r\n\r\n    private BufferedImage offScreenImage;\r\n\r\n    public void drawBlur(Graphics g) {\r\n        // Create off-screen image with the same dimensions as the game screen\r\n        if (offScreenImage == null || offScreenImage.getWidth() != Game.GAME_WIDTH || offScreenImage.getHeight() != Game.GAME_HEIGHT) {\r\n            offScreenImage = new BufferedImage(Game.GAME_WIDTH, Game.GAME_HEIGHT, BufferedImage.TYPE_INT_ARGB);\r\n        }\r\n\r\n        // Get graphics object of the off-screen image\r\n        Graphics2D g2d = offScreenImage.createGraphics();\r\n\r\n        // Draw all game elements onto the off-screen image\r\n        drawGame(g2d);\r\n\r\n        // Apply blur effect to the off-screen image\r\n        applyBlurEffect();\r\n\r\n        // Draw the blurred image onto the main graphics context\r\n        g.drawImage(offScreenImage, 0, 0, null);\r\n\r\n        // Add black opacity\r\n        g.setColor(new Color(0,0,0,150));\r\n        g.fillRect(0,0,Game.GAME_WIDTH,Game.GAME_HEIGHT);\r\n\r\n        // Dispose of the off-screen graphics object to release system resources\r\n        g2d.dispose();\r\n    }\r\n\r\n    public void draw(Graphics g) {\r\n        drawGame(g);\r\n    }\r\n\r\n    private void drawGame(Graphics g) {\r\n        // Draw background\r\n        drawSky(g);\r\n        drawForest(g);\r\n        drawSmallClouds(g);\r\n        drawBigClouds(g);\r\n\r\n        // Draw UI\r\n        drawMarioIcon(g);\r\n        drawCoinIcon(g);\r\n        drawHealthText(g);\r\n        drawCoinCount(g);\r\n\r\n        // Draw game\r\n        objectManager.drawPowerups(g, levelOffset);\r\n        levelManager.draw(g, levelOffset);\r\n        enemyManager.draw(g, levelOffset);\r\n        objectManager.draw(g, levelOffset);\r\n        player.draw(g, levelOffset);\r\n    }\r\n\r\n    private void applyBlurEffect() {\r\n        // Define blur matrix\r\n        final float a = 0.1f;\r\n        final float b = 0.2f;\r\n        float[] matrix = {\r\n                a, a, a,\r\n                a, b, a,\r\n                a, a, a\r\n        };\r\n\r\n        // Create blur filter\r\n        Kernel kernel = new Kernel(3, 3, matrix);\r\n        ConvolveOp blur = new ConvolveOp(kernel, ConvolveOp.EDGE_NO_OP, null);\r\n\r\n        // Apply blur filter to the off-screen image\r\n        offScreenImage = blur.filter(offScreenImage, null);\r\n    }\r\n\r\n    private void drawSky(Graphics g) {\r\n        int x = (int) (-levelOffset * 0.17);\r\n        int y = 0;\r\n        int w = (int) (4320  * Game.SCALE);\r\n        int h = Game.GAME_HEIGHT;\r\n        for (int i = 0; i < 8; i++) {\r\n            g.drawImage(SKY, x + i * w, y, w, h, null);\r\n        }\r\n\r\n    }\r\n\r\n    // ====== Background ======\r\n\r\n    private void drawForest(Graphics g) {\r\n        int x = (int) (-levelOffset * 0.17);\r\n        int y = (int) (230 * Game.SCALE);\r\n        int w = (int) (1024 / 2 * Game.SCALE);\r\n        int h = (int) (1024 / 2 * Game.SCALE);\r\n        for (int i = 0; i < 8; i++) {\r\n            g.drawImage(FOREST, x + i * w, y, w, h, null);\r\n        }\r\n    }\r\n\r\n    float bigX;\r\n    float smallX;\r\n    float incr;\r\n    private static final int CLOUDS_W = 1500;\r\n\r\n    private void drawSmallClouds(Graphics g) {\r\n        // set opacity\r\n        Graphics2D g2d = (Graphics2D) g;\r\n        g2d.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.5f));\r\n\r\n        if (levelOffset == 0 || levelOffset == levelManager.getLevel().getMaxLevelOffset() || player.direction == STILL) {\r\n//            smallX -= 0.08f;\r\n//            incr += 0.08f;\r\n        } else {\r\n//            smallX = -levelOffset * 0.08f - incr;\r\n        }\r\n\r\n        smallX = -levelOffset * 0.08f;\r\n\r\n        for (int i = 0; i < 4; i++) {\r\n            g.drawImage(SMALL_CLOUDS, (int) smallX + i * CLOUDS_W, 25, null);\r\n        }\r\n\r\n        // reset opacity\r\n        g2d.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 1f));\r\n    }\r\n\r\n    private void drawBigClouds(Graphics g) {\r\n\r\n        // cloud direction\r\n        if (levelOffset == 0 || levelOffset == levelManager.getLevel().getMaxLevelOffset() || player.direction == STILL) {\r\n//            bigX -= 0.5f;\r\n//            incr += 0.5f;\r\n        } else {\r\n//            bigX = -levelOffset * 0.25f - incr;\r\n        }\r\n\r\n        bigX = -levelOffset * 0.25f;\r\n\r\n        // draw 4 clouds\r\n        for (int i = 0; i < 4; i++) {\r\n            g.drawImage(BIG_CLOUDS, (int) bigX + i * CLOUDS_W, 80, null);\r\n        }\r\n    }\r\n\r\n    // ====== UI ======\r\n\r\n    private void drawMarioIcon(Graphics g) {\r\n        g.drawImage(MARIO, MARIO_X, MARIO_Y,MARIO_W, MARIO_H,null);\r\n    }\r\n\r\n    private void drawHealthText(Graphics g) {\r\n        // X\r\n        Graphics2D g2d = (Graphics2D) g;\r\n        g.setFont(CUSTOM_FONT.deriveFont(sizeX));\r\n        int w = g.getFontMetrics().stringWidth(\"x\");\r\n        TextLayout tl = new TextLayout(\"x\", g.getFont(), g2d.getFontRenderContext());\r\n        Shape shape = tl.getOutline(null);\r\n        AffineTransform transform = AffineTransform.getTranslateInstance(X_NEXT_TO_ICON, TOP_Y);\r\n        g2d.transform(transform);\r\n\r\n        // draw black X\r\n        g2d.setStroke(new BasicStroke(5f));\r\n        g2d.setColor(new Color(5, 5, 5));\r\n        g2d.draw(shape);\r\n\r\n        // draw white X\r\n        g2d.setColor(new Color(224, 224, 224));\r\n        g2d.fill(shape);\r\n        g2d.setTransform(new AffineTransform());\r\n\r\n        // HEALTH\r\n        final String health = (player.getHealth() < 10) ? \"0\" + player.getHealth() : String.valueOf(player.getHealth());\r\n        g.setFont(g.getFont().deriveFont(size00));\r\n        int x2 = (int) (X_NEXT_TO_ICON + w + 2 * Game.SCALE);\r\n        TextLayout tl2 = new TextLayout(health, g.getFont(), g2d.getFontRenderContext());\r\n        Shape shape2 = tl2.getOutline(null);\r\n        AffineTransform transform2 = AffineTransform.getTranslateInstance(x2, TOP_Y);\r\n        g2d.transform(transform2);\r\n\r\n        // draw black\r\n        g2d.setStroke(new BasicStroke(5f));\r\n        g2d.setColor(new Color(5, 5, 5));\r\n        g2d.draw(shape2);\r\n\r\n        // draw white\r\n        g2d.setColor(new Color(224, 224, 224));\r\n        g2d.fill(shape2);\r\n\r\n        // restore the original transform\r\n        g2d.setTransform(new AffineTransform());\r\n    }\r\n\r\n    private void drawCoinIcon(Graphics g) {\r\n        g.drawImage(COIN, MARIO_X, COIN_Y,MARIO_W, MARIO_H,null);\r\n    }\r\n\r\n    private void drawCoinCount(Graphics g) {\r\n        String coins = (coinCount <= 9) ? \"0\" + coinCount : String.valueOf(coinCount);\r\n\r\n        Graphics2D g2d = (Graphics2D) g;\r\n        g.setFont(g.getFont().deriveFont(size00));\r\n        TextLayout tl = new TextLayout(coins, g.getFont(), g2d.getFontRenderContext());\r\n        Shape shape2 = tl.getOutline(null);\r\n        int y = (int) (COIN_Y + MARIO_H - 4 * Game.SCALE);\r\n        AffineTransform transform = AffineTransform.getTranslateInstance(X_NEXT_TO_ICON, y);\r\n        g2d.transform(transform);\r\n\r\n        // draw black\r\n        g2d.setStroke(new BasicStroke(5f));\r\n        g2d.setColor(new Color(5, 5, 5));\r\n        g2d.draw(shape2);\r\n\r\n        // draw white\r\n        g2d.setColor(new Color(224, 224, 224));\r\n        g2d.fill(shape2);\r\n\r\n        // restore the original transform\r\n        g2d.setTransform(new AffineTransform());\r\n    }\r\n\r\n    private void drawCountdownTimer(Graphics g) {\r\n        String countdown = (t < 100 && t >= 10) ? \"0\" + t : (t < 10) ? \"00\" + t : String.valueOf(t);\r\n        Graphics2D g2d = (Graphics2D) g;\r\n        g.setFont(g.getFont().deriveFont(48f));\r\n        TextLayout tl = new TextLayout(countdown, g.getFont(), g2d.getFontRenderContext());\r\n        Shape shape = tl.getOutline(null);\r\n        int w = g.getFontMetrics().stringWidth(countdown);\r\n        int x = Game.GAME_WIDTH - MARIO_X - w;\r\n        AffineTransform transform = AffineTransform.getTranslateInstance(x, TOP_Y);\r\n        g2d.transform(transform);\r\n\r\n        // draw black\r\n        g2d.setStroke(new BasicStroke(5f));\r\n        g2d.setColor(new Color(5, 5, 5));\r\n        g2d.draw(shape);\r\n\r\n        // draw white\r\n        g2d.setColor(new Color(224, 224, 224));\r\n        g2d.fill(shape);\r\n\r\n        // restore the original transform\r\n        g2d.setTransform(new AffineTransform());\r\n\r\n    }\r\n\r\n    // ====== Reset methods ======\r\n\r\n    private void resetSpawnPoint() {\r\n        // Set saved spawn\r\n        if (spawnPoint != null)\r\n            spawnPoint = new Point((int) player.hitbox.x, (int) player.hitbox.y);\r\n\r\n        // Otherwise, get spawn point from map\r\n        else\r\n            spawnPoint = levelManager.getLevel().getSpawnPoint();\r\n\r\n        // Put player hitbox at the point\r\n        player.getHitbox().x = spawnPoint.x;\r\n        player.getHitbox().y = spawnPoint.y;\r\n    }\r\n\r\n    private void resetLevelData() {\r\n        // set new level data where we reset all the bricks (temp value 91, to its default value of 26)\r\n        int[][] levelData = levelManager.getLevel().getLevelData();\r\n        for (int i = 0; i < levelData.length; i++)\r\n            for (int j = 0; j < levelData[i].length; j++)\r\n                if (levelData[i][j] == 91)\r\n                    levelData[i][j] = 26;\r\n    }\r\n\r\n    public void resetGame() {\r\n        player.resetPlayer();\r\n        enemyManager.resetEnemies();\r\n        objectManager.resetAllObjects();\r\n        resetSpawnPoint();\r\n        resetLevelData();\r\n        coinCount = 0;\r\n        t = START_T;\r\n    }\r\n\r\n    public void resetGameGoToMenu() {\r\n        spawnPoint = null;\r\n        resetGame();\r\n        game.setGameState(MENU);\r\n    }\r\n\r\n    public void resetGameSavePoint() {\r\n        spawnPoint = new Point((int) player.getHitbox().x, (int) player.getHitbox().y);\r\n        resetGame();\r\n        game.setGameState(MENU);\r\n    }\r\n\r\n    public void resetGameGoToPlaying() {\r\n        spawnPoint = null;\r\n        resetGame();\r\n        game.setGameState(PLAYING);\r\n    }\r\n\r\n    public void resetGameLoadNextLevel() {\r\n        // Load next level\r\n        final int nextLevel = levelManager.getLevelIndex() + 1;\r\n        levelManager.setLevelIndex(nextLevel);\r\n\r\n        player.setLevel(levelManager.getLevel()); // todo not necc prob\r\n\r\n        resetGame();\r\n\r\n        // Start playing\r\n        game.setGameState(PLAYING);\r\n    }\r\n\r\n    public void setLevelCompleted() {\r\n        // calculate grade by factors speed and coins\r\n        // A below 80 seconds and 30 coins\r\n        if (coinCount >= 30 && t >= 220) {\r\n            System.out.println(\"Grade: A\");\r\n        } else if (coinCount >= 20 && t >= 200) {\r\n            System.out.println(\"Grade: B\");\r\n        } else if (coinCount >= 10 && t >= 150) {\r\n            System.out.println(\"Grade: C\");\r\n        } else {\r\n            System.out.println(\"Grade: D\");\r\n        }\r\n\r\n        // Set level complete or game complete, if at the last level\r\n        final int currentLevel = game.getPlaying().getLevelManager().getLevelIndex();\r\n        final int last = game.getPlaying().getLevelManager().getAmountOfLevels() - 1;\r\n        if (currentLevel == last)\r\n            game.setGameState(GAME_COMPLETED);\r\n        else\r\n            game.setGameState(LEVEL_COMPLETED);\r\n    }\r\n\r\n    // ====== Key and Mouse events ======\r\n\r\n    public void keyPressed(KeyEvent e) {\r\n        switch (e.getKeyCode()) {\r\n            case KeyEvent.VK_SPACE:\r\n                player.setJumping(true);\r\n                player.setHoldingSpace(true);\r\n                break;\r\n            case KeyEvent.VK_A:\r\n                movingLeft = true;\r\n                if (movingRight)\r\n                    player.setDirection(STILL);\r\n                else\r\n                    player.setDirection(LEFT);\r\n                break;\r\n            case KeyEvent.VK_D:\r\n                movingRight = true;\r\n                if (movingLeft)\r\n                    player.setDirection(STILL);\r\n                else\r\n                    player.setDirection(RIGHT);\r\n                break;\r\n            case KeyEvent.VK_K:\r\n                player.setAttacking(true);\r\n                break;\r\n            case KeyEvent.VK_P:\r\n            case KeyEvent.VK_ESCAPE:\r\n                game.setGameState(PAUSED);\r\n                break;\r\n        }\r\n\r\n    }\r\n\r\n    public void keyReleased(KeyEvent e) {\r\n        switch (e.getKeyCode()) {\r\n            case KeyEvent.VK_SPACE:\r\n                player.setJumping(false);\r\n                player.setCanJump(true);\r\n                player.setHoldingSpace(false);\r\n                break;\r\n            // Key released; Stop moving by setting the variables to false\r\n            case KeyEvent.VK_A:\r\n                movingLeft = false;\r\n                break;\r\n            case KeyEvent.VK_D:\r\n                movingRight = false;\r\n                break;\r\n        }\r\n\r\n        // Handle when key released, set new direction\r\n        if (movingLeft)\r\n            player.setDirection(LEFT);\r\n        else if (movingRight)\r\n            player.setDirection(RIGHT);\r\n        else\r\n            player.setDirection(STILL);\r\n    }\r\n\r\n    public void mousePressed(MouseEvent e) {\r\n        if (e.getButton() == MouseEvent.BUTTON1)\r\n            player.setAttacking(true);\r\n    }\r\n\r\n    // ====== Getters ======\r\n\r\n    public EnemyManager getEnemyManager() {\r\n        return enemyManager;\r\n    }\r\n\r\n    public LevelManager getLevelManager() {\r\n        return levelManager;\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/Playing.java b/src/main/Playing.java
--- a/src/main/Playing.java	(revision 0d95de5f2bac4e8bae1ac4e19c75723b868cea30)
+++ b/src/main/Playing.java	(date 1682896126984)
@@ -15,6 +15,7 @@
 
 import static constants.Direction.*;
 import static constants.GameState.*;
+import static main.Entity.*;
 import static main.Player.PLAYER_HEIGHT;
 import static main.Player.PLAYER_WIDTH;
 import static objects.Coin.coinCount;
@@ -491,10 +492,6 @@
 
     public void keyPressed(KeyEvent e) {
         switch (e.getKeyCode()) {
-            case KeyEvent.VK_SPACE:
-                player.setJumping(true);
-                player.setHoldingSpace(true);
-                break;
             case KeyEvent.VK_A:
                 movingLeft = true;
                 if (movingRight)
@@ -509,6 +506,10 @@
                 else
                     player.setDirection(RIGHT);
                 break;
+            case KeyEvent.VK_SPACE:
+                player.setJumping(true);
+                player.setHoldingSpace(true);
+                break;
             case KeyEvent.VK_K:
                 player.setAttacking(true);
                 break;
@@ -517,16 +518,48 @@
                 game.setGameState(PAUSED);
                 break;
         }
+        updateDirection();
+    }
+
+    private float acceleration = 0.2f;
+    private float velocity = 0.0f;
 
+    public void updateDirection() {
+        if (movingLeft) {
+            velocity -= acceleration;
+        } else if (movingRight) {
+            velocity += acceleration;
+        } else {
+            if (velocity > 0) {
+                velocity -= acceleration;
+                if (velocity < 0) {
+                    velocity = 0;
+                }
+            } else if (velocity < 0) {
+                velocity += acceleration;
+                if (velocity > 0) {
+                    velocity = 0;
+                }
+            }
+        }
+
+        if (velocity < -xSpeed) {
+            velocity = -xSpeed;
+        } else if (velocity > xSpeed) {
+            velocity = xSpeed;
+        }
+
+        if (velocity < 0) {
+            direction = LEFT;
+        } else if (velocity > 0) {
+            direction = RIGHT;
+        } else {
+            direction = STILL;
+        }
     }
 
     public void keyReleased(KeyEvent e) {
         switch (e.getKeyCode()) {
-            case KeyEvent.VK_SPACE:
-                player.setJumping(false);
-                player.setCanJump(true);
-                player.setHoldingSpace(false);
-                break;
             // Key released; Stop moving by setting the variables to false
             case KeyEvent.VK_A:
                 movingLeft = false;
@@ -534,15 +567,17 @@
             case KeyEvent.VK_D:
                 movingRight = false;
                 break;
+            case KeyEvent.VK_SPACE:
+                player.setJumping(false);
+                player.setCanJump(true);
+                player.setHoldingSpace(false);
+                break;
         }
 
-        // Handle when key released, set new direction
-        if (movingLeft)
-            player.setDirection(LEFT);
-        else if (movingRight)
-            player.setDirection(RIGHT);
-        else
-            player.setDirection(STILL);
+        if (!movingLeft && !movingRight) {
+            velocity = 0.0f;
+        }
+        updateDirection();
     }
 
     public void mousePressed(MouseEvent e) {
